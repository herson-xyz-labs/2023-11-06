<!doctype html>

<html>
  <head>
    <meta charset="utf-8">
    <title>WebGPU Life</title>
  </head>
  <body>
    <canvas width="512" height="512"></canvas>
    <script type="module">

    const GRID_SIZE = 32;
    
    const canvas = document.querySelector("canvas");

    if (!navigator.gpu) {
        throw new Error("WebGPU not supported on this browser.");
    }

    const adapter = await navigator.gpu.requestAdapter();

    if (!adapter) {
        throw new Error("No appropriate GPUAdapter found.");
    }
    
    const device = await adapter.requestDevice();

    const context = canvas.getContext("webgpu");
    const canvasFormat = navigator.gpu.getPreferredCanvasFormat();

    context.configure({
        device: device,
        format: canvasFormat,
    });

    const cellVerticesArray = new Float32Array([
        -0.8, -0.8, 
        0.8, -0.8,
        0.8,  0.8,

        -0.8, -0.8, 
        0.8,  0.8,
        -0.8,  0.8,
    ]);

    const cellVertexBuffer = device.createBuffer({
        label: "Cell vertices",
        size: cellVerticesArray.byteLength, 
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
    });

    device.queue.writeBuffer(cellVertexBuffer, /*bufferOffset=*/0, cellVerticesArray);

    const cellVertexBufferLayout = {
        arrayStride: 8,
        attributes: [{  
            format: "float32x2",
            offset: 0,
            shaderLocation: 0,
        }],
    };

    /*
        Communicate the grid size to the shader using a uniform buffer.
    */

    const gridSizeUniformArray = new Float32Array([GRID_SIZE, GRID_SIZE]);
    
    const gridSizeUniformBuffer = device.createBuffer({
        label: "Grid Uniforms",
        size: gridSizeUniformArray.byteLength,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });

    device.queue.writeBuffer(gridSizeUniformBuffer, 0, gridSizeUniformArray);

    const cellShaderModule = device.createShaderModule({
        label: "Cell shader",
        code: 
        `
            @group(0) @binding(0) var<uniform> grid: vec2f;

            /*
                - Reposition the geometries on a per-instance basis, using the built-in instance index.
                - The instance index is u32, so we need to convert it to f32 to use it in the shader.
            */
            @vertex
            fn vertexMain(@location(0) pos:vec2f,
                          @builtin(instance_index) instance: u32) ->
                          @builtin(position) vec4f 
            {

                /*
                    - pos + vec2f(1, 1)                             - moves the position half a clip space unit to the right and up, so that the bottom left corner of the grid is at the origin.
                    - (pos + vec2f(1, 1)) / grid                    - scales down the vectors so that they stay relative to the grid size.
                    - vec2f(-1, -1)                                 - translates the vectors half a clip space unit to the left and down, so that the bottom left corner of the grid is at the bottom left corner of the canvas.
                    
                    - Equivalent: gridPos = (pos + 1) / grid - 1;

                    - vec2f(i % grid.x, floor(i / grid.x))          - For each cell's X value, you want the modulo of the instance_index and the grid width, 
                                                                      which you can perform in WGSL with the % operator. And for each cell's Y value you want 
                                                                      the instance_index divided by the grid width, discarding any fractional remainder. 
                                                                      You can do that with WGSL's floor() function.
                */

                let i = f32(instance);
                let coordOffset = vec2f(i % grid.x, floor(i / grid.x));                  // Vector that holds the amounts to offset the cell in the grid.
                let uvCoordOffset = coordOffset / grid * 2;                              // Normalized vector that holds the amounts to offset the cell in the grid.
                let gridPos = (pos + vec2f(1, 1)) / grid + vec2f(-1, -1) + uvCoordOffset;

                return vec4f(gridPos, 0, 1);
            }

            @fragment
            fn fragmentMain() -> @location(0) vec4f { // @location(0) maps to the colorAttachments[0] settings in the render pass below
                return vec4f(1, 0, 0, 1);
            }
        `
    });
    
    const cellPipeline = device.createRenderPipeline(
    {
        label: "Cell pipeline",
        layout: "auto",
        vertex: {
            module: cellShaderModule,
            entryPoint: "vertexMain",
            buffers: [cellVertexBufferLayout]
    },
        fragment: {
            module: cellShaderModule,
            entryPoint: "fragmentMain",
            targets: [{
                format: canvasFormat
            }]
    }
    });

    /*
        A bind group is a collection of resources that you want to make accessible to your shader at the same time. 
        It can include several types of buffers, like your uniform buffer, and other resources like textures and samplers.
    */

    const bindGroup = device.createBindGroup({
        label: "Cell renderer bind group",
        layout: cellPipeline.getBindGroupLayout(0),
        entries: [{
            binding: 0,
            resource: { buffer: gridSizeUniformBuffer }
        }],
    });
    
    const encoder = device.createCommandEncoder();

    const pass = encoder.beginRenderPass({
        colorAttachments: [{
            view: context.getCurrentTexture().createView(),
            loadOp: "clear",
            clearValue: { r: 0, g: 0, b: 0.4, a: 1 },
            storeOp: "store",
        }],
    });

    pass.setPipeline(cellPipeline);
    pass.setVertexBuffer(0, cellVertexBuffer);
    pass.setBindGroup(0, bindGroup);

    /*
        Instancing the geometry to draw a grid of cells, by passing the number of instances to draw as the second argument to draw().
    */

    pass.draw(cellVerticesArray.length / 2, GRID_SIZE * GRID_SIZE);

    pass.end();

    const commandBuffer = encoder.finish();

    device.queue.submit([commandBuffer]);

    </script>
  </body>
</html>