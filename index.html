<!doctype html>

<html>
  <head>
    <meta charset="utf-8">
    <title>WebGPU Life</title>
  </head>
  <body>
    <canvas width="512" height="512"></canvas>
    <script type="module">

    const GRID_SIZE = 32;
    const UPDATE_INTERVAL = 200; // Update every 200ms (5 times/sec)
    let step = 0; // Track how many simulation steps have been run

    const canvas = document.querySelector("canvas");

    if (!navigator.gpu) {
        throw new Error("WebGPU not supported on this browser.");
    }

    const adapter = await navigator.gpu.requestAdapter();

    if (!adapter) {
        throw new Error("No appropriate GPUAdapter found.");
    }
    
    const device = await adapter.requestDevice();

    const context = canvas.getContext("webgpu");
    const canvasFormat = navigator.gpu.getPreferredCanvasFormat();

    context.configure({
        device: device,
        format: canvasFormat,
    });

    const cellVerticesArray = new Float32Array([
        -0.8, -0.8, 
        0.8, -0.8,
        0.8,  0.8,

        -0.8, -0.8, 
        0.8,  0.8,
        -0.8,  0.8,
    ]);

    const cellVertexBuffer = device.createBuffer({
        label: "Cell vertices",
        size: cellVerticesArray.byteLength, 
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
    });

    device.queue.writeBuffer(cellVertexBuffer, /*bufferOffset=*/0, cellVerticesArray);

    const cellVertexBufferLayout = {
        arrayStride: 8,
        attributes: [{  
            format: "float32x2",
            offset: 0,
            shaderLocation: 0,
        }],
    };

    const gridSizeUniformArray = new Float32Array([GRID_SIZE, GRID_SIZE]);
    
    const gridSizeUniformBuffer = device.createBuffer({
        label: "Grid Uniforms",
        size: gridSizeUniformArray.byteLength,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });

    device.queue.writeBuffer(gridSizeUniformBuffer, 0, gridSizeUniformArray);

    /*
        Create a storage buffer to store the state of each cell.
        We need to be able to both read and write to this buffer, since the state gets updated every frame.
        Also, thinking ahead, we want cell state to represent 'aliveness' so we use a Float32Array instead of a Uint32Array.
    */

    const cellStateArray = new Float32Array(GRID_SIZE * GRID_SIZE);

    for (let i = 0; i < cellStateArray.length; i += 3) {
        cellStateArray[i] = 1;
    }

    const cellStateBuffer = [
        device.createBuffer({
            label: "Cell State A",
            size: cellStateArray.byteLength,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
        }),
        device.createBuffer({
            label: "Cell State B",
            size: cellStateArray.byteLength,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
        })
    ];

    device.queue.writeBuffer(cellStateBuffer[0], 0, cellStateArray);

    for (let i = 0; i < cellStateArray.length; i++) {
        cellStateArray[i] = i % 2;
    }
    device.queue.writeBuffer(cellStateBuffer[1], 0, cellStateArray);
    
    const cellShaderModule = device.createShaderModule({
        label: "Cell shader",
        code: 
        `
            struct VertexInput {
                @location(0) pos: vec2f,
                @builtin(instance_index) instance: u32,
            };

            struct VertexOutput {
                @builtin(position) pos: vec4f,
                @location(0) cell: vec2f,
            };

            @group(0) @binding(0) var<uniform> grid: vec2f;
            @group(0) @binding(1) var<storage> cellState: array<f32>;

            @vertex
            fn vertexMain(input: VertexInput) -> VertexOutput
            {
                let i = f32(input.instance);
                let coordOffset = vec2f(i % grid.x, floor(i / grid.x));                  
                let uvCoordOffset = coordOffset / grid * 2;
                let cellState = cellState[input.instance]; // Query the cell's state from the storage buffer.                              
                let gridPos = (input.pos * cellState + vec2f(1, 1)) / grid + vec2f(-1, -1) + uvCoordOffset; // Scale the position by the cell's active state.

                var output: VertexOutput;
                output.pos = vec4f(gridPos, 0, 1);
                output.cell = uvCoordOffset;
                return output;
            }

            @fragment
            fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {
                return vec4f(input.cell, 1 - input.cell.x, 1);
            }
        `
    });
    
    const cellPipeline = device.createRenderPipeline(
    {
        label: "Cell pipeline",
        layout: "auto",
        vertex: {
            module: cellShaderModule,
            entryPoint: "vertexMain",
            buffers: [cellVertexBufferLayout]
    },
        fragment: {
            module: cellShaderModule,
            entryPoint: "fragmentMain",
            targets: [{
                format: canvasFormat
            }]
    }
    });

    const bindGroups = [
    device.createBindGroup({
        label: "Cell renderer bind group A",
        layout: cellPipeline.getBindGroupLayout(0),
        entries: [{
        binding: 0,
        resource: { buffer: gridSizeUniformBuffer }
        }, {
        binding: 1,
        resource: { buffer: cellStateBuffer[0] }
        }],
    }),
    device.createBindGroup({
        label: "Cell renderer bind group B",
        layout: cellPipeline.getBindGroupLayout(0),
        entries: [{
        binding: 0,
        resource: { buffer: gridSizeUniformBuffer }
        }, {
        binding: 1,
        resource: { buffer: cellStateBuffer[1] }
        }],
    })
    ];
    
    async function renderLoop(){
        step++; // Increment the step count

        const encoder = device.createCommandEncoder();

        const pass = encoder.beginRenderPass({
            colorAttachments: [{
                view: context.getCurrentTexture().createView(),
                loadOp: "clear",
                clearValue: { r: 0, g: 0, b: 0.4, a: 1 },
                storeOp: "store",
            }],
        });

        pass.setPipeline(cellPipeline);
        pass.setVertexBuffer(0, cellVertexBuffer);
        pass.setBindGroup(0, bindGroups[step % 2]);

        pass.draw(cellVerticesArray.length / 2, GRID_SIZE * GRID_SIZE);

        pass.end();

        const commandBuffer = encoder.finish();

        device.queue.submit([commandBuffer]);
    }
    setInterval(renderLoop, UPDATE_INTERVAL);
    </script>
  </body>
</html>